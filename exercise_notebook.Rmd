---
title: "Bioinformatics exercise"
output: html_notebook
---



```{r Setup phase, message=FALSE, warning=FALSE}

# Install Bioconductor - uncomment on first run
source("https://bioconductor.org/biocLite.R")
biocLite()

# Install edgeR
biocLite("edgeR")
library(limma)
library(edgeR)
# installing packages - uncomment on first run
# install.packages("ggplot2")
library(ggplot2)

#install.packages("devtools")
library(devtools)

#install.packages("ggfortify")
library(ggfortify)


```

```{r Raw data import}

# Import the raw dataset
sample_annotation <- read.delim("data/sample-annotation.txt")
gene_annotation <- read.delim("data/gene-annotation.txt")
counts <- read.delim("data/counts.txt", stringsAsFactors = TRUE)

```

```{r Initial cleaning - form DGEList, message=FALSE, warning=FALSE}

# explore the properties of the gene-annotation 
dim(gene_annotation)
summary(gene_annotation)
head(gene_annotation)

# the same for sample annotation
dim(sample_annotation)
head(sample_annotation)

# seems like categorical variable
table(sample_annotation$type)

# look at the count data-set, extract quantiles
dim(counts)
colnames(counts)[1] <- "ENSEMBL"

# now sure the annotation and counts are consistent
# it seems we have quite a lot of missing gene annotations
length(unique(counts$ENSEMBL))
length(unique(gene_annotation$ENSEMBL))
missing_annotations <- setdiff(unique(counts$ENSEMBL), unique(gene_annotation$ENSEMBL))
sprintf("The number of missing annotations %s out of %s", length(missing_annotations), length(unique(counts$ENSEMBL)))

# decided to remove genes with missing annotations at the moement
counts <- counts[-(which(missing_annotations %in% counts$ENSEMBL)),]
dim(counts)

# look for missing sample metadata
length(unique(sample_annotation$sample_id))
length(unique(colnames(counts)[-1]))
setdiff(sample_annotation$sample_id, colnames(counts)[-1])
# we have complete per-sample metadata

# convert columns to numeric
toConvert <- colnames(counts)[-1]
counts[,toConvert] = apply(counts[,toConvert], 2, function(x) as.numeric(as.character(x)));

# Form a DGEList - not working at the moment
y <- DGEList(counts[,-1], 
             genes = gene_annotation,
             remove.zeros = TRUE,
             samples = sample_annotation,
             group = sample_annotation$type)

```

```{r Filter the count data for lowly-expressed genes}
# normalize counts to cpm, require value >= 1 for a valid measure
valid_cpm <- as.data.frame(cpm(y) >= 1)

# Kinda ugly - need to optimize this approach...
# ...but the idea is to mark each gene as valid or not, per group
# we denote 'valid'as 75% or more cases of valid cpm, per gene (per group)
normal_col_idx <- which(y$samples$group %in% "lesional")
lesional_col_idx <- which(y$samples$group %in% "normal")
toKeep_normal <- rowSums(valid_cpm[,normal_col_idx]) > 0.75*length(normal_col_idx)
toKeep_lesional <- rowSums(valid_cpm[,lesional_col_idx]) > 0.75*length(lesional_col_idx)
toKeep <- (union(names(toKeep_normal[toKeep_normal]),names(toKeep_lesional[toKeep_lesional])))
sprintf("Remaining with %s genes out of %s",length(toKeep), length(counts$ENSEMBL))
y$counts <- y$counts[toKeep,]
#count_qnt <- t(apply(counts[,-1], 1, quantile, probe = c(.25,.75), na.rm = FALSE))
```

```{r Generate an object that contains the library-size normalized log-CPM, message=FALSE, warning=FALSE}
logCPM_normByLibSize <- cpm(y, log = TRUE, normalized.lib.sizes = TRUE)
save(aveLogCPM_normByLibSize, file = "logCPM_normByLibSize.rda")
```

```{r Basic data plotting}
#plotMD(y)

# plot the library size, per sample
ggplot(data=y$samples, aes(x=1:length(y$samples$sample_id),y=lib.size)) + geom_bar(stat="identity") + ggtitle("Library size per sample (millions)")

# multi-dimentional scaling plot
y2 <- calcNormFactors(y)
col <- as.numeric(y2$samples$type)
mds <- plotMDS(y2, top=200, col=col)
plotMDS(mds, col=col, labels=y2$samples$sample_id)


# density
###norm_logCPM <- colSums(logCPM_normByLibSize)/sum(logCPM_normByLibSize)
###plot(density(norm_logCPM))
###plot(density(as.vector(norm_logCPM*1000000)))

# pca plor per group - another way....
##pca.normal <- prcomp(t( logCPM_normByLibSize[, normal_col_idx]), scale = T)
##pca.lesional <- prcomp(t( logCPM_normByLibSize[, lesional_col_idx]), scale = T)
##screeplot(pca.normal, type="lines")


```

```{r Identify outliers from the PA analysis}

```

