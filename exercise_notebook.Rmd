---
title: "Bioinformatics exercise"
output: html_notebook
---



```{r Setup phase, message=FALSE, warning=FALSE}

# Install Bioconductor - uncomment on first run
source("https://bioconductor.org/biocLite.R")
biocLite()

# Install edgeR
biocLite("edgeR")
library(limma)
library(edgeR)
# installing packages - uncomment on first run
# install.packages("ggplot2")
library(ggplot2)

#install.packages("devtools")
library(devtools)

#install.packages("ggfortify")
library(ggfortify)

# Only if I need to use OutlierMahdist
#library(rrcovHD)

```

```{r Raw data import}

# Import the raw dataset
sample_annotation <- read.delim("data/sample-annotation.txt")
gene_annotation <- read.delim("data/gene-annotation.txt")
counts <- read.delim("data/counts.txt", stringsAsFactors = TRUE)

```

```{r Initial cleaning - form DGEList, message=FALSE, warning=FALSE}

# explore the properties of the gene-annotation 
dim(gene_annotation)
summary(gene_annotation)
head(gene_annotation)

# the same for sample annotation
dim(sample_annotation)
head(sample_annotation)

# seems like categorical variable
table(sample_annotation$type)

# look at the count data-set, extract quantiles
dim(counts)
colnames(counts)[1] <- "ENSEMBL"

# now sure the annotation and counts are consistent
# it seems we have quite a lot of missing gene annotations
length(unique(counts$ENSEMBL))
length(unique(gene_annotation$ENSEMBL))
missing_annotations <- setdiff(unique(counts$ENSEMBL), unique(gene_annotation$ENSEMBL))
sprintf("The number of missing annotations %s out of %s", length(missing_annotations), length(unique(counts$ENSEMBL)))

# decided to remove genes with missing annotations at the moement
counts <- counts[-(which(missing_annotations %in% counts$ENSEMBL)),]
dim(counts)

# look for missing sample metadata
length(unique(sample_annotation$sample_id))
length(unique(colnames(counts)[-1]))
setdiff(sample_annotation$sample_id, colnames(counts)[-1])
# we have complete per-sample metadata

# convert columns to numeric
toConvert <- colnames(counts)[-1]
counts[,toConvert] = apply(counts[,toConvert], 2, function(x) as.numeric(as.character(x)));

# Form a DGEList - a basic data structure for working with RNA seq
y <- DGEList(counts[,-1], 
             genes = gene_annotation,
             remove.zeros = TRUE,
             samples = sample_annotation,
             group = sample_annotation$type)
# Note that using calcNormFactors does not change the counts: it just updates the column norm.factors in $samples
y <- calcNormFactors(y) 

```

```{r Filter the count data for lowly-expressed genes}
# normalize counts to cpm, require value >= 1 for a valid measure
y$cpm <- cpm(y)
valid_cpm <- as.data.frame( y$cpm >= 1)

# Kinda ugly - need to optimize this approach...
# ...but the idea is to mark each gene as valid or not, per group
# we denote 'valid'as 75% or more cases of valid cpm, per gene (per group)
normal_col_idx <- which(y$samples$group %in% "lesional")
toKeep_normal <- rowSums(valid_cpm[,normal_col_idx]) > 0.75*length(normal_col_idx)

lesional_col_idx <- which(y$samples$group %in% "normal")
toKeep_lesional <- rowSums(valid_cpm[,lesional_col_idx]) > 0.75*length(lesional_col_idx)

toKeep <- (union(names(toKeep_normal[toKeep_normal]),names(toKeep_lesional[toKeep_lesional])))
sprintf("Remaining with %s genes out of %s",length(toKeep), length(counts$ENSEMBL))
y.pre_filtered <- y
y$counts <- y$counts[toKeep,]
```

```{r Generate an object that contains the library-size normalized log-CPM, message=FALSE, warning=FALSE}
y$logcom <- cpm(y, log = TRUE, normalized.lib.sizes = TRUE)
saveRDS(y$logcom, file = "logCPM.normalizaed.rda")
```

```{r Basic data plotting}

# general properties of the dataset - may be able to avoid these vars
group <- as.numeric(y$samples$type)
nsamples <- ncol(y)

# plot the library size, per sample
ggplot(data=y$samples, aes(x=1:length(y$samples$sample_id),y=lib.size)) + 
  geom_bar(stat="identity" ,color=y$samples$type) + 
  ggtitle("Library size per sample (millions)")


# density
# the density is - on the x axis - the log-cpm
# the y-axis the frequenvy
# we can se several curevs - one per sample, and how they are distributed across genes.


{
  y.pre_filtered$logcpm <- cpm(y.pre_filtered, normalized.lib.sizes = TRUE, log = TRUE)
  plot(density(y.pre_filtered$logcpm[,1]), col=y.pre_filtered$samples$type[1], lwd=1,ylim=c(0,0.6), las=2,main="",xlab="")
  title(main="A. before data cleaning", xlab="Log-cpm")
  abline(v=0, lty=2)
  for (i in 2:ncol(y.pre_filtered)){
   den <- density(y.pre_filtered$logcpm[,i])
   lines(den$x, den$y, col=y.pre_filtered$samples$type[i], lwd=1)
  }
}
{
  plot(density(y$logcom[,1]), col=y$samples$type[1], lwd=1,ylim=c(0,0.21), las=2,main="",xlab="")
  title(main="B. after data filtering", xlab="Log-cpm")
  abline(v=0, lty=2)
  for (i in 2:ncol(y)){
   den <- density(y$logcom[,i])
   lines(den$x, den$y, col=y$samples$type[i], lwd=1)
  }
}
```

```{r Identify outliers from the PCA analysis}

# PCA - multi-dimentional scaling plot
mds <- plotMDS(y, top=200, col=as.numeric(y$samples$type))

# PCA plot, with group coloring
local({
  pc <- prcomp(t(cpm(y)))
  autoplot(pc, data = y$samples, colour = 'type', label.repel = TRUE, label.size = 2)
  
})

# extract outliers from matrix after PCA
print("We notice that sample SRR1146216 is probably mislabeled, so we omit that sample.")
y$counts <- y$counts[,-c(which(y$samples$sample_id %in% "SRR1146216"))]
y$samples <- y$samples[-c(which(y$samples$sample_id %in% "SRR1146216")),]
print(dim(y$samples))
```

```{r Differential expression analysis comparing lesional vs normal}
# Relevel the 'type' field, so 'normal' will have the factor value of 1
# Hence, the model.matrix when turning 'type' to dummay vairable, will treat 'normal' as 0
# and 'lesional' as 1
y$samples$type <- relevel(y$samples$type, 'normal')
design <- model.matrix(data = y$samples, ~type)
y <- estimateDisp(y, design)
fit <- glmQLFit(y,design)
qlf <- glmQLFTest(fit,coef=2)
top.tags <- topTags(qlf, n=200)
```

```{r Export the GE analysis results}
write.table(top.tags, "de.analysis", sep = "\t", row.names = F)
```

